/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <math.h>

typedef struct {
	volatile uint32_t MODER;
	volatile uint32_t OTYPER;
	volatile uint32_t OSPEEDR;
	volatile uint32_t PUPDR;
	volatile uint32_t IDR;
	volatile uint32_t ODR;
	volatile uint32_t BSRR;
	volatile uint32_t LCKR;
	volatile uint32_t AFRL;
	volatile uint32_t AFRH;
	volatile uint32_t BRR;
			 uint32_t reserved;
	volatile uint32_t SECCFGR;
}GPIO_Type;


#define RCC_AHB2ENR *((volatile uint32_t *) (0x40021000 + 0x4C))
#define RCC_APB1ENR *((volatile uint32_t *) (0x40021000 + 0x058))

#define TIM6_CR1 *((volatile uint16_t *) (0x40001000))
#define TIM6_SR *((volatile uint16_t *) (0x40001000 + 0x10))
#define TIM6_CNT *((volatile uint32_t *) (0x40001000 + 0x24))
#define TIM6_PSC *((volatile uint16_t *) (0x40001000 + 0x28))
#define TIM6_ARR *((volatile uint16_t *) (0x40001000 + 0x2C))

#define GPIOA ((GPIO_Type*) (0x42020000 + 0x000))
#define GPIOC ((GPIO_Type*) (0x42020000 + 0x800))

int main(void) {
	uint32_t wait_milisecond = 1000;

	RCC_APB1ENR |= 0x01 << 4; //enable timer clock
	RCC_AHB2ENR |= 0x01 << 0; //enable port a
	RCC_AHB2ENR |= 0x01 << 2; //enable port c

	GPIOA->MODER &= ~(0x03 << (6)); // trigger output pa3
	GPIOA->MODER |= (0x01 << (6)); //trigger output pa3

	GPIOA->MODER &= ~(0x03 << (9 * 2)); // red led pa9
	GPIOA->MODER |= (0x01 << (9 * 2)); //red led pa9

	GPIOC->MODER &= ~(0x03 << (6)); // echo input pc3

	TIM6_PSC = 3; //prescaler
	int index;
	while (1) {

		for (index = 0; index < wait_milisecond * 33; index++);

		TIM6_SR = 0; //clear UIF bit
		TIM6_ARR = 10;
		TIM6_CNT = 0; //reset counter

		GPIOA->ODR |= (0x01 << 3); //trigger high
		TIM6_CR1 |= 1; //enable timer count

		while ((TIM6_SR & 1) == 0); //wait until 10 microsecond

		GPIOA->ODR &= ~(0x01 << 3); //trigger low
		TIM6_CR1 &= ~1; //disable timer count


		while ((GPIOC->IDR & (1 << 3)) == 0); //wait while echo is 0
		//echo becomes high
		TIM6_SR = 0;
		TIM6_ARR = 0xFFFF;
		TIM6_CNT = 0;

		TIM6_CR1 |= 1; //enable timer count

		while((GPIOC->IDR & (1 << 3)) != 0); //wait while echo is 1

		//echo becomes low
		TIM6_CR1 &= ~1; //disable timer count
		int cycle = TIM6_CNT;

		double distance = (cycle * 34000 * pow(10, -6)) / 2;
		if ( distance < 10) {
			GPIOA->ODR |= (0x01 << 9); //red open
		} else {
			GPIOA->ODR &= ~(0x01 << 9); //red close
		}


	}
}
